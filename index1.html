# Main Gameplay
while True:
    sc.update()
    
    # Boundary check
    if h.xcor() > 290 or h.xcor() < -290 or h.ycor() > 290 or h.ycor() < -290:
        time.sleep(1)
        h.goto(0, 0)
        h.direction = "Stop"
        f.goto(random.randint(-270, 270), random.randint(-270, 270))
        for seg in seg:
            seg.goto(1000, 1000)
        seg.clear()
        s = 0
        d = 0.1
        p.clear()
        p.write(f"Score : {s} High Score : {hs}", align="center", font=("candara", 24, "bold"))
    
    # Food collision
    if h.distance(f) < 20:
        f.goto(random.randint(-270, 270), random.randint(-270, 270))

        # Adding segment
        n_seg = t.Turtle()
        n_seg.speed(0)
        n_seg.shape("square")
        n_seg.color("orange")
        n_seg.penup()
        seg.append(n_seg)
        d -= 0.001
        s += 10
        if s > hs:
            hs = s
        p.clear()
        p.write(f"Score : {s} High Score : {hs}", align="center", font=("candara", 24, "bold"))
    
    # Move segments
    for i in range(len(seg)-1, 0, -1):
        x, y = seg[i-1].xcor(), seg[i-1].ycor()
        seg[i].goto(x, y)
    
    if len(seg) > 0:
        x, y = h.xcor(), h.ycor()
        seg[0].goto(x, y)
    
    # Move head
    move()

    # Checking for self-collision
    for segment in seg:
        if segment.distance(h) < 20:
            time.sleep(1)
            h.goto(0, 0)
            h.direction = "Stop"
            f.goto(random.randint(-270, 270), random.randint(-270, 270))
            for seg in seg:
                seg.goto(1000, 1000)
            seg.clear()
            s = 0
            d = 0.1
            p.clear()
            p.write(f"Score : {s} High Score : {hs}", align="center", font=("candara", 24, "bold"))
    
    time.sleep(d)